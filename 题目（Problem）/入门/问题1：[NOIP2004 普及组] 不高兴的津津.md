## 问题1：[NOIP2004 普及组] 不高兴的津津

**题目描述**
津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

**输入格式**
输入包括77行数据，分别表示周一到周日的日程安排。每行包括两个小于1010的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

**输出格式**
一个数字。如果不会不高兴则输出00，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 71,2,3,4,5,6,7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

**输入输出样例**

输入 #1

```
5 3
6 2
7 2
5 3
5 4
0 4
0 6
```

输出 #1

```
3
```



讲解

* 本题涉及到二维数组知识点
* 也可以使用算法一这种途中解



算法一（最优解）：也可以是途中解

```C
#include <stdio.h>

int main() {
    int a, b, day=0, i, max=0;
    for(i=1;i<=7;i++) {
        scanf("%d %d", &a, &b);
        if((a+b)>max&&(a+b)>8) {
            max = a + b;
            day = i;
        }
    }
    printf("%d", day);
    return 0;
}
```



算法二（我的版本）

```C
#include <stdio.h>

int main() {
    int day[2][7], i, j, max=0;
    for(i=0;i<7;i++) {
        for(j=0;j<7;j++) {
            scanf("%d %d", &a, &b);
        }
    }
	
    int sum;
	for(i=0;i<7;i++) {
		sum = 0;
		for(j=0;j<2;j++) {
			sum+=input[i][j];
		}
		if(sum>8) {
			printf("%d", i+1);
			break;
		}
	}
	
	if(sum==0) {
		printf("%d", 0);
	}
    return 0;
}
```







算法三（我的第2个版本）

```C
#include <stdio.h>

int main() {
	int a, b;
	int c[7];
	int count = 0;
	int max=0;
	int i;
	for(i=0;i<7;i++) {
		scanf("%d %d", &a, &b);
		c[i]=a+b;
		if(c[i]>8&&c[i]>max) {
			max = c[i];
			count = i;
		}
	}
	if(max==0) printf("%d", 0);
	else printf("%d", count+1);
	return 0;
}
```







算法四



## 问题2：肥胖问题

**题目描述**
BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 XXXXXX其中 mm 是指体重（千克），hh 是指身高（米）。不同体型范围与判定结果如下：

* 小于 18.5：体重过轻，输出 Underweight；
* 大于等于 18.5 且小于 24：正常体重，输出 Normal；
* 大于等于 24：肥胖，不仅要输出 BMI 值（使用 cout 的默认精度），然后换行，还要输出 Overweight；
  现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。

对于非 C++ 语言，在输出时，请四舍五入保留六位有效数字输出，如果小数部分存在后缀 00，不要输出后缀 00。

请注意，保留六位有效数字不是保留六位小数。例如 114.5149114.5149 应该输出为 114.515114.515，9198.10 9198.10 应该输出为 9198.19198.1。

**输入格式**
m 和 h 均不超过 3 位小数

**输出格式**
无

**输入输出样例**

输入 #1

```
70 1.72
```


输出 #1复制

```
Normal
```



算法/题解

```C
#include <stdio.h>

int main() {
	double m, h;
	double result;
	
	scanf("%lf %lf", &m, &h);
	
	result = m/(h*h);
	
	if(result<18.5) {
		printf("Underweight");
	} else if(result<24) {
		printf("Normal");
	} else {
		printf("%.4f\nOverweight", result);//目的是保留六位有效数字
	}
	return 0;
}
```

* 算法虽然通过，但无法略掉类似1.10，这样后面带有0的数





## 问题3：【深基3.例2】数的性质

**题目描述**
一些数字可能拥有以下的性质：

* 性质 1：是偶数；
* 性质 2：大于 4 且不大于 12。

小A 喜欢这两个性质同时成立的数字；Uim 喜欢这至少符合其中一种性质的数字；八尾勇喜欢刚好有符合其中一个性质的数字；正妹喜欢不符合这两个性质的数字。

**输入格式**
输入一个数字 x(0\le x \le 1000)x(0≤x≤1000)

**输出格式**
输出这 4 个人是否喜欢这个数字，如果喜欢则输出1，否则输出0，用空格分隔。

**输入输出样例**
输入 #1

```
12
```


输出 #1



题解

```C
#include <stdio.h>

int main() {
	int x;
	int a=0, b=0, c=0, d=0;
	
	scanf("%d", &x);
	
	int i;
	for(i=0;i<4;i++) {
		switch(i) {
			case 0:
				if(!(x&1)&&x>4&&x<=12)
				  a=1;
			break;
			case 1:
				if(!(x&1)||(x>4&&x<=12))
				  b=1;
			break;
			case 2:
				if(!(x&1)&&!(x>4&&x<=12))
				  c=1;
				else if((x&1)&&(x>4&&x<=12))
				  c=1;
			break;
			case 3:
				if((x&1)&&!(x>4&&x<=12))
				  d=1;
			break;
		}
	}
	printf("%d %d %d %d", a, b, c, d);
	return 0;
	
}
```





```C
#include <stdio.h>

int main() {
	int x;
	scanf("%d", &x);	
	int a=!(x&1), b=(x>4&&x<=12), c, d;
	printf("%d %d %d %d", a&&b, a||b, (a&&!b)||(!a&&b), !a&&!b);
	
	return 0;
}
```









## 问题4 [NOIP2016 普及组] 买铅笔

**题目描述**
P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有 33种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P老师决定只买同一种包装的铅笔。

商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过nn支铅笔才够给小朋 友们发礼物。

现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少nn支铅笔最少需要花费多少钱。

**输入格式**
第一行包含一个正整数nn，表示需要的铅笔数量。

接下来三行，每行用22个正整数描述一种包装的铅笔：其中第11个整数表示这种 包装内铅笔的数量，第22个整数表示这种包装的价格。

保证所有的77个数都是不超过1000010000的正整数。

**输出格式**
11个整数，表示P老师最少需要花费的钱。

**输入输出样例**

| 输入 #1                        | 输出 #1 | 输入 #2                                   | 输出 #2 | 输入 #3                                    | 输出 #3 |
| ------------------------------ | ------- | ----------------------------------------- | ------- | ------------------------------------------ | ------- |
| 57<br/>2 2<br/>50 30<br/>30 27 | 54      | 9998<br/>128 233<br/>128 2333<br/>128 666 | 18407   | 9999<br/>101 1111<br/>1 9999<br/>1111 9999 | 89991   |



**说明/提示**
铅笔的三种包装分别是：

* 2支装，价格为2;
* 50支装，价格为30;
* 30支装，价格为27。
* P老师需要购买至少57支铅笔。

如果她选择购买第一种包装，那么她需要购买2929份，共计2×29=58支，需要花费的钱为2×29=58。

实际上，P老师会选择购买第三种包装，这样需要买22份。虽然最后买到的铅笔数 量更多了，为30×2=60支，但花费却减少为27×2=54，比第一种少。

对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买22份，实际的花费达到了30×2=60，因此P老师也不会选择。

所以最后输出的答案是54。

















```C
#include <stdio.h>

int main() {
	int need, money[3];
	int i, result;
	int a, b;
	
	scanf("%d", &need);
	
	for(i=0;i<3;i++) {
		scanf("%d %d", &a, &b);
		if((need/a)==(1.0*need/a)) money[i]=(need/a)*b;
		else money[i]=(need/a+1)*b;
		
		if(i==0) result = money[0];
		
		if(money[i]<result) result = money[i];
	}
	
	printf("%d", result);
	return 0;
}
```



```C
#include <stdio.h>

int main() {
	int need, money[3];
	int i, result;
	int a, b;
	
	scanf("%d", &need);
	for(i=0;i<3;i++) {
		scanf("%d %d", &a, &b);
		if((need/a)==(1.0*need/a)) money[i]=(need/a)*b;
		else money[i]=(need/a+1)*b;
		
		if(i==0) result = money[0];
		
		if(money[i]<result) result = money[i];
	}
	
	printf("%d", result);
	return 0;
}
```



```C
#include <stdio.h>

int main() {
	int need, pen[3][2], money[3];
	int i, j;
	int result;
	
	scanf("%d", &need);
	
	for(i=0;i<3;i++) {
		for(j=0;j<2;j++) {
			scanf("%d", &pen[i][j]);
		}
		if((need/pen[i][0])==(1.0*need/pen[i][0]) ) money[i]=(need/pen[i][0])*pen[i][1];
		else money[i] = (need/pen[i][0]+1)*pen[i][1];
	}
	
	result = money[0];
	for(i=0;i<3;i++) {
		if(money[i]<result) result = money[i];
	}
	
	printf("%d", result);
	return 0;
}
```



算法一（最优解）

```C
#include <stdio.h>

int main() {
	int need, money[3];
	int i, result;
	int a, b;
	
	scanf("%d", &need);
	for(i=0;i<3;i++) {
		scanf("%d %d", &a, &b);
		if(need%a==0) money[i]=(need/a)*b;
		else money[i]=(need/a+1)*b;
		
		if(i==0) result = money[0];
		
		if(money[i]<result) result = money[i];
	}
	
	printf("%d", result);
	return 0;
}
```





## 问题5：[NOIP2008 普及组] ISBN 号码

**题目描述**
每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括99位数字、11位识别码和33位分隔符，其规定格式如x-xxx-xxxxx-x，其中符号-就是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如00代表英语；第一个分隔符-之后的三位数字代表出版社，例如670670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这99个数字，从左至右，分别乘以1,2,...,9再求和，即0×1+6×2+……+2×9=158，然后取158mod11的结果4作为识别码。

你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出Right；如果错误，则输出你认为是正确的ISBN号码。

**输入格式**
一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。

**输出格式**
一行，假如输入的ISBN号码的识别码正确，那么输出Right，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符-）。

**输入输出样例**

| 输入 #1       | 输出 #1 | 输入 #2       | 输出 #2       |
| ------------- | ------- | ------------- | ------------- |
| 0-670-82162-4 | Right   | 0-670-82162-0 | 0-670-82162-4 |

**题解**

算法二（我的版本）：

```C
#include <stdio.h>

int main() {
	char number[14];
	char letter[12] = "0123456789X";
	int i;
	int sum=0;
	int count = 1;
	scanf("%s", &number); 
	
	number[13] = '\0';
	
	for(i=0;i<11;i++) {
		if(number[i] == '-') continue;
		sum += (number[i]-48)*count;//这里的话不用加else了，因为只要上面的一旦执行就会跳过这次循环了
	    count++;
	}
	
	if(letter[sum%11]==number[12]) {
		printf("Right");
	} else {
		number[12] = letter[sum%11];
		printf("%s", number);
	}
	return 0;
}
```



算法一：

```C
//1.读入字符串
//2.自己建立一个数组用来包含0123456789X用于对照
//3.利用ASCII码的差值来计算字符数字对应的实际数字
#include <stdio.h>

int main(){
    char a[14];
    char mod[12]="0123456789X";
    gets(a);
    int i=0;
    int j=1;
    int t=0;
    for(i=0;i<12;i++){
        if(a[i]=='-' ) continue;
            t+=(a[i]-'0')*j;
            j++;
    }
    if(mod[t%11]==(a[12])){
        printf("Right");
    }else{
        a[12]=mod[t%11];
        puts(a);
    }
    return 0;
}
```



算法三

```C
#include<stdio.h>	
char num[15];
int main(){
	int i,j,flag,in;
	flag=j=0;
	for(i=0;;i++) {
		if(j==3) {
			break;
		}
        
		scanf("%c",&num[i]);
        
		if(num[i]=='-') {
			i--;
			j++;
		} else if(num[i]!='-') {
			flag=(num[i]-'0')*(i+1)+flag;
		}
	}
	
    flag=flag%11;
	scanf("%c",&num[14]);
    
	if(flag==10) {
		if(num[14]=='X') printf("Right");
		else printf("%c-%c%c%c-%c%c%c%c%c-X",num[0],num[1],num[2],num[3],num[4],num[5],num[6],num[7],num[8]);
	} else {
		if(flag==num[14]-'0') printf("Right");
		else if(flag!=10) printf("%c-%c%c%c-%c%c%c%c%c-%d",num[0],num[1],num[2],num[3],num[4],num[5],num[6],num[7],num[8],flag);
		else if(flag==10) printf("%c-%c%c%c-%c%c%c%c%c-%d",num[0],num[1],num[2],num[3],num[4],num[5],num[6],num[7],num[8],flag);
	}
	return 0;
}
```



算法四

```C
#include <stdio.h>//代码简洁明了（个人观点）
int main(void){
  char a[14], mod[12] = "0123456789X"; //先将mod11后的十一个字符存入数组
  gets(a); //输入字符串
  int i, j = 1, t = 0;
  for(i = 0; i < 12; i++) {
        if(a[i] == '-') continue; //字符串为分隔符‘-’时跳过此次循环进入下一次循环
    t += (a[i]-'0')*j++; //t储存 第j个  数字  * j 的和
  }
  if(mod[t%11] == a[12]) printf("Right");
  else {
      a[12] = mod[t%11]; //若识别码错误，则赋正确的识别码，然后输出
      puts(a);
  }
  return 0;
}
```





## 问题6：【深基3.例8】三位数排序

**题目描述**
给出三个整数a,b,c(0≤a,b,c≤100)，要求把这三位整数从小到大排序。

**输入格式**
无

**输出格式**
无

**输入输出样例**

| 输入 #1 | 输出 #1 | 输入 #2 | 输出 #2 |
| ------- | ------- | ------- | ------- |
| 1 14 5  | 1 5 14  | 2 2 2   | 2 2 2   |



题解

```C
#include<stdio.h>
int main(){
	int a[3];
	scanf("%d%d%d",&a[0],&a[1],&a[2]);
	for(int i=0;i<3;i++) {
		for(int j=i+1;j<3;j++) {
			if(a[i]>a[j]) {
				int t=a[i];
				a[i]=a[j];
				a[j]=t;
			}
		}
		printf("%d ",a[i]);
	}
	return 0;
}
```





